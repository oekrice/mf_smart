#New script to do helicity analysis on both the original LARE 'magnetograms' and anything generated by MF. Used to determine the 'best' value for the myserious omega.


import numpy as np
import matplotlib.pyplot as plt
import sys
import matplotlib
from scipy.io import netcdf_file
from scipy.interpolate import RegularGridInterpolator
from scipy.fft import fft, ifft2, fft2, ifft
import os
from scipy.ndimage import gaussian_filter

class Grid():
    """In the interest of doing it properly, put grid parameters in here"""
    def __init__(self, run):

        paras = np.loadtxt('parameters/variables%03d.txt' % run)

        import_resolution = 128

        #Define the grid onto which the electric field should be outputted
        self.nx = import_resolution
        self.ny = import_resolution

        self.x0 = paras[12]; self.x1 = paras[13]
        self.y0 = paras[14]; self.y1 = paras[15]

        self.xs = np.linspace(self.x0, self.x1, self.nx+1)
        self.ys = np.linspace(self.y0, self.y1, self.ny+1)

        self.dx = self.xs[1] - self.xs[0]
        self.dy = self.ys[1] - self.ys[0]

        self.xc = np.linspace(self.x0 - self.dx/2, self.x1 + self.dx/2, self.nx+2)
        self.yc = np.linspace(self.y0 - self.dy/2, self.y1 + self.dy/2, self.ny+2)

        self.dx = self.xs[1] - self.xs[0]
        self.dy = self.ys[1] - self.ys[0]

        self.xs_import = np.linspace(self.x0, self.x1, import_resolution+1)
        self.ys_import = np.linspace(self.y0, self.y1, import_resolution+1)


        self.dx_import = self.xs[1] - self.xs[0]
        self.dy_import = self.ys[1] - self.ys[0]

        self.xc_import = np.linspace(self.x0 - self.dx/2, self.x1 + self.dx/2, import_resolution+2)
        self.yc_import = np.linspace(self.y0 - self.dy/2, self.y1 + self.dy/2, import_resolution+2)


def compute_helicity(run, mag_number):
    #Uses all three components of the magnetic field to give values for A.B at EACH of the input timesteps.
    #Requires the script from Chris' flt code
    grid = Grid(0)
    #Call run = -1 the reference case
    omegas = []

    source = './mf_mags/%03d/' % run

    data_directory = source

    bfield_fname = '%s%04d.nc' % (data_directory, mag_number)

    try:
        data = netcdf_file(bfield_fname, 'r', mmap=False)

    except:
        print('File', bfield_fname, 'not found')
        raise Exception('Output file not found')

    bx_in = np.swapaxes(data.variables['bx'][:],0,1)
    by_in = np.swapaxes(data.variables['by'][:],0,1)
    bz_in = np.swapaxes(data.variables['bz'][:],0,1)
    #Trim the edges out as these can go a bit screwy and bugger up the results
    bx = np.zeros((np.shape(bx_in)))
    by = np.zeros((np.shape(by_in)))
    bz = np.zeros((np.shape(bz_in)))

    bx[1:-1,1:-1] = bx_in[1:-1,1:-1]
    by[1:-1,1:-1] = by_in[1:-1,1:-1]
    bz[1:-1,1:-1] = bz_in[1:-1,1:-1]

    #Need to average these to grid centres to get the FFT to work
    bx0 = 0.5*(bx[1:,:] + bx[1:,:])
    by0 = 0.5*(by[:,1:] + by[:,:-1])
    bz0 = bz[:,:]

    mag_nx = bz.shape[0]; mag_ny = bz.shape[1]
    mag_dx = (grid.xs[-1] - grid.xs[0])/mag_nx
    mag_dy = (grid.ys[-1] - grid.ys[0])/mag_ny


    def norm2d(vec):
        mag = np.linalg.norm(vec)
        if (mag > 0.0):
            v = vec/mag
        else:
            v = np.array([0, 0])
        return np.array([v[0],v[1],0.0])

    def getFrequencyMatrix(ncells,spacing):
        freqlist1da =np.roll(np.linspace(-ncells[0]/2,ncells[0]/2-1,ncells[0]),round(ncells[0]/2))/(ncells[0]*spacing[0])
        freqlist1db =np.roll(np.linspace(-ncells[1]/2,ncells[1]/2-1,ncells[1]),round(ncells[1]/2))/(ncells[1]*spacing[1])
        return np.array([np.array([np.array([2.0*np.pi*freqlist1da[i],2.0*np.pi*freqlist1db[j]]) for j in range(len(freqlist1db))]) for i  in range(len(freqlist1da))]);

    #Find in -plane vector potential in the winding gauge

    fm = getFrequencyMatrix([mag_nx, mag_ny],[mag_dx, mag_dy]);
    # make the basis

    kparr = np.array([np.array([norm2d(fm[i][j]) for j in range(len(fm[0]))]) for i  in range(len(fm))]);
    kperp = np.array([np.array([np.array([-kparr[i][j][1],kparr[i][j][0],0.0]) for j in range(len(fm[0]))]) for i  in range(len(fm))])
    # note in the k matrix below the k=0 element is set to one so we can divide by it.
    k = np.array([np.array([1.0 if i==j==0 else np.linalg.norm(fm[i][j]) for i in range(len(fm))]) for j  in range(len(fm[0]))]).T

    nx = bz.shape[0]; ny = bz.shape[1]
    aftx = np.zeros([bz.shape[0],bz.shape[1]],dtype=np.complex128)
    afty = np.zeros([bz.shape[0],bz.shape[1]],dtype=np.complex128)
    aftz = np.zeros([bz.shape[0],bz.shape[1]],dtype=np.complex128)

    fbx = fft2(bx0[:,:]); fby = fft2(by0[:,:]); fbz = fft2(bz0[:,:])

    akperp = -1j*fbz/k
    ## fix i =j  element
    akw = 1j*(-(kparr[:,:,1])*fbx + (kparr[:,:,0])*fby)/k
    ## fix i =j  element
    aftx[:,:] = akperp*kperp[:,:,0]
    afty[:,:] = akperp*kperp[:,:,1]
    aftz[:,:] = akperp*kperp[:,:,2]+akw

    ax0 = ifft2(aftx[:,:])
    ay0 = ifft2(afty[:,:])
    az0 = ifft2(aftz[:,:])
    ax0 = np.real(ax0)
    ay0 = np.real(ay0)
    az0 = np.real(az0)

    ax = np.zeros((nx, ny+1))
    ay = np.zeros((nx+1, ny))

    ax[:,1:-1] = 0.5*(ax0[:,1:] + ax0[:,:-1])
    ay[1:-1,:] = 0.5*(ay0[1:,:] + ay0[:-1,:])

    bz_test = (ay[1:,:] - ay[:-1,:])/mag_dx - (ax[:,1:] - ax[:,:-1])/mag_dy

    #print('Vector potential test', np.max(np.abs(bz[1:-1,1:-1] - bz_test[1:-1,1:-1]))/np.max(np.abs(bz[1:-1,1:-1])))
    #This vector potential should be reasonably OK... Need code to test though

    hfield = ax0*bx0 + ay0*by0 + az0*bz0

    hfield = np.sqrt(np.abs(hfield))

    return np.sum(np.abs(hfield)*mag_dx*mag_dy)

def compare_fields(run, mag_number):
    #Compares the initial magnetograms and the test, in a yet-to-be decided manner (which is hopefully fast)
    #Use L2 norms and things, perhaps.

    #Get MHD ones first

    grid = Grid(0)
    #Call run = -1 the reference case
    omegas = []

    source = './magnetograms/'

    data_directory = source

    bfield_fname = '%s%04d.nc' % (data_directory, mag_number)

    try:
        data = netcdf_file(bfield_fname, 'r', mmap=False)

    except:
        print('File', bfield_fname, 'not found')
        raise Exception('Output file not found')

    bx_0 = data.variables['bx'][:]
    by_0 = data.variables['by'][:]
    bz_0 = data.variables['bz'][:]

    data.close()
    #Then MF ones

    grid = Grid(0)
    #Call run = -1 the reference case
    omegas = []

    source = './mf_mags/%03d/' % run

    data_directory = source

    bfield_fname = '%s%04d.nc' % (data_directory, mag_number)

    try:
        data = netcdf_file(bfield_fname, 'r', mmap=False)

    except:
        print('File', bfield_fname, 'not found')
        raise Exception('Output file not found')

    bx_1 = np.swapaxes(data.variables['bx'][:],0,1)
    by_1 = np.swapaxes(data.variables['by'][:],0,1)
    bz_1 = np.swapaxes(data.variables['bz'][:],0,1)

    data.close()

    #Need to do interolation onto a uniform scale (choose the smallest of these)
    nx_min = min(bz_0.shape[0], bz_1.shape[0])
    ny_min = min(bz_0.shape[1], bz_1.shape[1])

    xs = np.linspace(0,1,nx_min)
    ys = np.linspace(0,1,ny_min)

    X, Y = np.meshgrid(xs, ys, indexing = 'ij')

    bx0_fn = RegularGridInterpolator((np.linspace(0,1,bx_0.shape[0]), np.linspace(0,1,bx_0.shape[1])), bx_0, bounds_error = False, method = 'linear', fill_value = None)
    bx0_new = bx0_fn((X,Y))

    by0_fn = RegularGridInterpolator((np.linspace(0,1,by_0.shape[0]), np.linspace(0,1,by_0.shape[1])), by_0, bounds_error = False, method = 'linear', fill_value = None)
    by0_new = by0_fn((X,Y))

    bz0_fn = RegularGridInterpolator((np.linspace(0,1,bz_0.shape[0]), np.linspace(0,1,bz_0.shape[1])), bz_0, bounds_error = False, method = 'linear', fill_value = None)
    bz0_new = bz0_fn((X,Y))

    bx1_fn = RegularGridInterpolator((np.linspace(0,1,bx_1.shape[0]), np.linspace(0,1,bx_1.shape[1])), bx_1, bounds_error = False, method = 'linear', fill_value = None)
    bx1_new = bx1_fn((X,Y))

    by1_fn = RegularGridInterpolator((np.linspace(0,1,by_1.shape[0]), np.linspace(0,1,by_1.shape[1])), by_1, bounds_error = False, method = 'linear', fill_value = None)
    by1_new = by1_fn((X,Y))

    bz1_fn = RegularGridInterpolator((np.linspace(0,1,bz_1.shape[0]), np.linspace(0,1,bz_1.shape[1])), bz_1, bounds_error = False, method = 'linear', fill_value = None)
    bz1_new = bz1_fn((X,Y))


    #The bzs should match pretty exactly, but the others won't - try to minimise this. Would need different algorithm though as it's not going to be anywhere near zero...
    fig, axs = plt.subplots(3,3, figsize = (10,5))

    ax = axs[0,0]
    im = ax.pcolormesh(bx1_new)
    plt.colorbar(im, ax = ax)

    ax = axs[0,1]
    im = ax.pcolormesh(by1_new)
    plt.colorbar(im, ax = ax)

    ax = axs[0,2]
    im = ax.pcolormesh(bz1_new)
    plt.colorbar(im, ax = ax)

    ax = axs[1,0]
    im = ax.pcolormesh(bx0_new)
    plt.colorbar(im, ax = ax)

    ax = axs[1,1]
    im = ax.pcolormesh(by0_new)
    plt.colorbar(im, ax = ax)

    ax = axs[1,2]
    im = ax.pcolormesh(bz0_new)
    plt.colorbar(im, ax = ax)

    ax = axs[2,0]
    im = ax.pcolormesh(bx1_new - bx0_new)
    plt.colorbar(im, ax = ax)

    ax = axs[2,1]
    im = ax.pcolormesh(by1_new - by0_new)
    plt.colorbar(im, ax = ax)

    ax = axs[2,2]
    im = ax.pcolormesh(bz1_new - bz0_new)
    plt.colorbar(im, ax = ax)

    plt.tight_layout()
    plt.close()

    #Identify quantity to be minimised (somehow)
    diff1 = np.sum((bx1_new - bx0_new)**2)
    diff2 = np.sum((bx1_new - bx0_new)**2)

    print('bx diff', diff1, 'by diff', diff2)

    return diff1 + diff2





